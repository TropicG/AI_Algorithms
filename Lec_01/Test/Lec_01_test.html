<!DOCTYPE html>
<html lang="bg">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерактивен Тест: Търсене в пространството на състоянията</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .answer-btn {
            transition: background-color 0.3s, border-color 0.3s, transform 0.1s;
        }
        .answer-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .correct {
            background-color: #22c55e !important; /* green-500 */
            border-color: #16a34a !important; /* green-600 */
            color: white;
        }
        .incorrect {
            background-color: #ef4444 !important; /* red-500 */
            border-color: #dc2626 !important; /* red-600 */
            color: white;
        }
    </style>
</head>
<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 flex items-center justify-center min-h-screen p-4">
    <div id="quiz-container" class="bg-white dark:bg-slate-800 rounded-2xl shadow-2xl p-6 md:p-8 w-full max-w-3xl">
        <div id="quiz-header" class="mb-6">
            <h1 class="text-2xl md:text-3xl font-bold text-center text-slate-900 dark:text-white">Тест: Търсене в пространството на състоянията</h1>
            <div class="mt-4 bg-slate-100 dark:bg-slate-700 h-2.5 rounded-full">
                <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <p id="progress-text" class="text-center text-sm font-medium text-slate-600 dark:text-slate-400 mt-2">Въпрос 0 от 50</p>
        </div>

        <div id="question-area">
            <h2 id="question-text" class="text-lg md:text-xl font-semibold mb-5 text-center">Зареждане на въпрос...</h2>
            <div id="answer-buttons" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Answer buttons will be generated by JS -->
            </div>
        </div>

        <div id="feedback-area" class="mt-6 text-center">
            <p id="rationale-text" class="text-slate-600 dark:text-slate-300 min-h-[4rem] flex items-center justify-center p-2 border-2 border-transparent rounded-lg"></p>
        </div>
        
        <div id="navigation-area" class="mt-6 flex justify-center">
            <button id="next-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-all duration-300 hidden">Следващ въпрос</button>
        </div>

        <div id="result-area" class="hidden text-center">
            <h2 class="text-3xl font-bold mb-4 text-slate-900 dark:text-white">Резултати от теста</h2>
            <p id="score-text" class="text-xl mb-6">Вашият резултат е 0 от 50.</p>
            <p id="final-message" class="text-lg font-medium mb-8"></p>
            <button id="restart-btn" class="bg-slate-600 text-white font-bold py-3 px-8 rounded-lg shadow-md hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-50 transition-all duration-300">Започни отначало</button>
        </div>
    </div>

    <script>
        const quizDataRaw = {
            "questions": [{
                "questionNumber": 1,
                "question": "Кое от следните най-добре описва 'пространство на състоянията' (State Space) в контекста на изкуствения интелект?",
                "answerOptions": [{
                    "text": "Само началното и целевото състояние.",
                    "rationale": "Това са само два специфични компонента, а не цялото пространство.",
                    "isCorrect": false
                }, {
                    "text": "Последователността от действия за решаване на проблема.",
                    "rationale": "Това описва решението или пътя, а не пространството от всички възможности.",
                    "isCorrect": false
                }, {
                    "text": "Съвкупността от всички възможни състояния, достижими от началното състояние.",
                    "rationale": "Тази дефиниция обхваща всички възможни конфигурации, които агентът може да заеме.",
                    "isCorrect": true
                }, {
                    "text": "Графичното представяне на решението.",
                    "rationale": "Графът може да представи пространството, но не е самото пространство.",
                    "isCorrect": false
                }],
                "hint": "Помислете за дефиницията, която включва абсолютно всички възможни позиции или конфигурации."
            }, {
                "questionNumber": 2,
                "question": "Какво представлява 'функцията-наследник' (successor function) в един проблем за търсене?",
                "answerOptions": [{
                    "text": "Функция, която изчислява цената на пътя.",
                    "rationale": "Цената на пътя е отделна концепция, свързана с преходите, а не с генерирането им.",
                    "isCorrect": false
                }, {
                    "text": "Набор от правила, които определят възможните действия от дадено състояние.",
                    "rationale": "Тя генерира всички възможни следващи състояния от текущото.",
                    "isCorrect": true
                }, {
                    "text": "Алгоритъмът, който намира решението.",
                    "rationale": "Алгоритъмът използва функцията-наследник, но не е самата нея.",
                    "isCorrect": false
                }, {
                    "text": "Състоянието, което искаме да достигнем.",
                    "rationale": "Това е целевото състояние (goal state).",
                    "isCorrect": false
                }],
                "hint": "Тази функция отговаря на въпроса: 'Какви ходове мога да направя оттук?'"
            }, {
                "questionNumber": 3,
                "question": "В едно дърво за търсене (Search Tree), кое състояние обикновено представлява коренът на дървото?",
                "answerOptions": [{
                    "text": "Целевото състояние",
                    "rationale": "Целевите състояния обикновено са листа, а не корен.",
                    "isCorrect": false
                }, {
                    "text": "Началното състояние",
                    "rationale": "Търсенето винаги започва от началната точка, която формира корена на дървото.",
                    "isCorrect": true
                }, {
                    "text": "Междинно състояние",
                    "rationale": "Междинните състояния са възли между корена и листата.",
                    "isCorrect": false
                }, {
                    "text": "Терминално състояние (задънена улица)",
                    "rationale": "Терминалните състояния са листа, от които не може да се продължи.",
                    "isCorrect": false
                }],
                "hint": "Помислете откъде започва процесът на търсене."
            }, {
                "questionNumber": 4,
                "question": "Кой критерий за оценка на алгоритъм за търсене отговаря на въпроса: 'Ще намери ли алгоритъмът най-доброто решение?'",
                "answerOptions": [{
                    "text": "Пълнота (Completeness)",
                    "rationale": "Пълнотата гарантира намирането на някакво решение, но не задължително най-доброто.",
                    "isCorrect": false
                }, {
                    "text": "Времева сложност (Time complexity)",
                    "rationale": "Времевата сложност измерва скоростта, а не качеството на решението.",
                    "isCorrect": false
                }, {
                    "text": "Оптималност (Optimality)",
                    "rationale": "Оптималността се отнася точно до способността на алгоритъма да намери решението с най-ниска цена.",
                    "isCorrect": true
                }, {
                    "text": "Пространствена сложност (Space Complexity)",
                    "rationale": "Пространствената сложност измерва нужната памет, а не качеството на решението.",
                    "isCorrect": false
                }],
                "hint": "Търсим термина, който описва качеството на намереното решение, а не самото му намиране."
            }, {
                "questionNumber": 5,
                "question": "Какво измерва променливата 'b' (branching factor) при анализ на алгоритми за търсене?",
                "answerOptions": [{
                    "text": "Дълбочината на най-доброто решение.",
                    "rationale": "Това се описва с променливата 'd' (depth).",
                    "isCorrect": false
                }, {
                    "text": "Максималния брой наследници (нови избори) на един възел.",
                    "rationale": "Това е точно дефиницията за фактор на разклоняване.",
                    "isCorrect": true
                }, {
                    "text": "Общия брой възли в дървото за търсене.",
                    "rationale": "Общият брой възли зависи от 'b' и 'd', но 'b' е само един от факторите.",
                    "isCorrect": false
                }, {
                    "text": "Цената на пътя до решението.",
                    "rationale": "Цената е отделна метрика и не се описва с 'b'.",
                    "isCorrect": false
                }],
                "hint": "Тази променлива е свързана с 'ширината' на търсенето."
            }, {
                "questionNumber": 6,
                "question": "Коя е основната разлика между глобално (Global Search) и локално търсене (Local Search)?",
                "answerOptions": [{
                    "text": "Глобалното търсене използва повече памет.",
                    "rationale": "Въпреки че често е вярно, това е следствие, а не основната концептуална разлика.",
                    "isCorrect": false
                }, {
                    "text": "Локалното търсене се интересува само от крайното състояние, не и от пътя до него.",
                    "rationale": "Това е ключова характеристика; локалното търсене оптимизира състояние, докато глобалното търсене конструира път.",
                    "isCorrect": true
                }, {
                    "text": "Глобалното търсене е винаги по-бързо.",
                    "rationale": "Това не е вярно; локалното търсене може да бъде много по-бързо, макар и непълно.",
                    "isCorrect": false
                }, {
                    "text": "Локалното търсене винаги намира оптималното решение.",
                    "rationale": "Напротив, локалното търсене е податливо на засядане в локални оптимуми.",
                    "isCorrect": false
                }],
                "hint": "Помислете какво е важно за всеки тип търсене: стъпките или крайният резултат?"
            }, {
                "questionNumber": 7,
                "question": "Защо стратегиите като BFS и DFS се наричат 'неинформирани' (uninformed)?",
                "answerOptions": [{
                    "text": "Защото не могат да намерят решение.",
                    "rationale": "Те могат да намерят решение, но го правят без допълнителни насоки.",
                    "isCorrect": false
                }, {
                    "text": "Защото не използват информация за цената на пътя.",
                    "rationale": "Някои неинформирани стратегии, като UCS, използват информация за цената.",
                    "isCorrect": false
                }, {
                    "text": "Защото разполагат само с дефиницията на проблема и нямат насоки накъде е целта.",
                    "rationale": "Те не използват евристика или друга допълнителна информация, за да се насочат към целта.",
                    "isCorrect": true
                }, {
                    "text": "Защото работят само върху дървета, но не и върху графи.",
                    "rationale": "Те могат да бъдат адаптирани да работят и върху графи (с проверка за посетени възли).",
                    "isCorrect": false
                }],
                "hint": "Каква допълнителна информация би помогнала на търсенето да бъде по-ефективно?"
            }, {
                "questionNumber": 8,
                "question": "Каква структура от данни се използва приоритетно за реализация на Depth-First Search (DFS)?",
                "answerOptions": [{
                    "text": "Опашка (Queue)",
                    "rationale": "Опашката (FIFO) се използва за BFS, за да се поддържа търсене ниво по ниво.",
                    "isCorrect": false
                }, {
                    "text": "Стек (Stack)",
                    "rationale": "Стекът (LIFO - Last-In, First-Out) гарантира, че последният добавен възел ще бъде изследван пръв, което води до задълбочаване.",
                    "isCorrect": true
                }, {
                    "text": "Приоритетна опашка (Priority Queue)",
                    "rationale": "Приоритетната опашка се използва за алгоритми, които се влияят от цена, като UCS или A*.",
                    "isCorrect": false
                }, {
                    "text": "Хеш таблица (Hash Table)",
                    "rationale": "Хеш таблицата може да се използва за следене на посетени възли, но не е основната структура за управление на търсенето.",
                    "isCorrect": false
                }],
                "hint": "Помислете коя структура реализира принципа 'последният влязъл, пръв излязъл'."
            }, {
                "questionNumber": 9,
                "question": "Кой е основният недостатък на DFS по отношение на пълнотата (completeness)?",
                "answerOptions": [{
                    "text": "Винаги е много бавен.",
                    "rationale": "Времевата сложност може да е проблем, но не е причината за непълнотата му.",
                    "isCorrect": false
                }, {
                    "text": "Може да попадне в безкраен клон и никога да не намери решение.",
                    "rationale": "Ако графът има цикли или безкрайни пътища, DFS може да се 'загуби' и никога да не се върне назад.",
                    "isCorrect": true
                }, {
                    "text": "Изисква твърде много памет.",
                    "rationale": "Всъщност DFS е ефективен по отношение на паметта в сравнение с BFS.",
                    "isCorrect": false
                }, {
                    "text": "Не може да работи, ако цената на стъпките е различна.",
                    "rationale": "DFS не се интересува от цената на стъпките, така че това не е проблем за него.",
                    "isCorrect": false
                }],
                "hint": "Какво се случва, ако DFS поеме по път, който никога не свършва?"
            }, {
                "questionNumber": 10,
                "question": "Каква е времевата сложност на DFS в най-лошия случай, където 'b' е факторът на разклоняване и 'm' е максималната дълбочина?",
                "answerOptions": [{
                    "text": "O(b*m)",
                    "rationale": "Това описва пространствената, а не времевата сложност на DFS.",
                    "isCorrect": false
                }, {
                    "text": "O(b^d)",
                    "rationale": "Тази сложност е характерна за IDS, където 'd' е дълбочината на решението.",
                    "isCorrect": false
                }, {
                    "text": "O(b^m)",
                    "rationale": "В най-лошия случай DFS може да се наложи да обходи цялото дърво до максималната му дълбочина.",
                    "isCorrect": true
                }, {
                    "text": "O(d^b)",
                    "rationale": "Експонентата обикновено е дълбочината, а основата е факторът на разклоняване.",
                    "isCorrect": false
                }],
                "hint": "В най-лошия случай, алгоритъмът трябва да генерира всички възли до най-голямата възможна дълбочина."
            }, {
                "questionNumber": 11,
                "question": "Кой алгоритъм изследва пространството на състоянията ниво по ниво?",
                "answerOptions": [{
                    "text": "Depth-First Search (DFS)",
                    "rationale": "DFS върви в дълбочина, не на ширина.",
                    "isCorrect": false
                }, {
                    "text": "Uniform-Cost Search (UCS)",
                    "rationale": "UCS се разширява на база цена, не на база ниво.",
                    "isCorrect": false
                }, {
                    "text": "Breadth-First Search (BFS)",
                    "rationale": "Това е дефиницията на BFS - първо се изследват всички съседи, после техните съседи и т.н.",
                    "isCorrect": true
                }, {
                    "text": "Iterative Deepening Search (IDS)",
                    "rationale": "IDS симулира търсене ниво по ниво, но го прави чрез повтарящи се търсения в дълбочина.",
                    "isCorrect": false
                }],
                "hint": "Името на алгоритъма подсказва, че търсенето се разпространява 'нашироко'."
            }, {
                "questionNumber": 12,
                "question": "При какви условия Breadth-First Search (BFS) е гарантирано оптимален?",
                "answerOptions": [{
                    "text": "Винаги е оптимален.",
                    "rationale": "Това не е вярно, ако стъпките имат различни цени.",
                    "isCorrect": false
                }, {
                    "text": "Когато цената на всяка стъпка е еднаква (например 1).",
                    "rationale": "В този случай най-плиткото решение (което BFS намира) е и най-евтиното.",
                    "isCorrect": true
                }, {
                    "text": "Никога не е оптимален.",
                    "rationale": "Има специфични условия, при които той е оптимален.",
                    "isCorrect": false
                }, {
                    "text": "Когато пространството на състоянията е дърво.",
                    "rationale": "Структурата на пространството не е достатъчно условие; цените на стъпките са ключови.",
                    "isCorrect": false
                }],
                "hint": "Помислете какво означава 'оптимален' - най-малко стъпки или най-ниска цена?"
            }, {
                "questionNumber": 13,
                "question": "Кой е основният недостатък на BFS по отношение на сложността?",
                "answerOptions": [{
                    "text": "Изисква твърде много памет (пространствена сложност).",
                    "rationale": "BFS трябва да пази в паметта всички възли на текущото и следващото ниво, което може да доведе до експоненциален растеж.",
                    "isCorrect": true
                }, {
                    "text": "Има висока времева сложност, но ниска пространствена.",
                    "rationale": "И двете сложности са експоненциални в най-лошия случай.",
                    "isCorrect": false
                }, {
                    "text": "Не е пълен.",
                    "rationale": "BFS е пълен - ако има решение, той ще го намери.",
                    "isCorrect": false
                }, {
                    "text": "Работи бавно на плитки дървета.",
                    "rationale": "Напротив, BFS е много ефективен за намиране на плитки решения.",
                    "isCorrect": false
                }],
                "hint": "Сравнете количеството възли, които DFS и BFS трябва да пазят едновременно."
            }, {
                "questionNumber": 14,
                "question": "Какво търси алгоритъмът Uniform-Cost Search (UCS)?",
                "answerOptions": [{
                    "text": "Пътя с най-малко стъпки.",
                    "rationale": "Това е целта на BFS, когато всички стъпки са с еднаква цена.",
                    "isCorrect": false
                }, {
                    "text": "Пътя с най-ниска обща цена.",
                    "rationale": "UCS винаги разширява възела с най-ниска кумулативна цена от началото, което гарантира намирането на най-евтиния път.",
                    "isCorrect": true
                }, {
                    "text": "Първото намерено решение, независимо от цена или стъпки.",
                    "rationale": "Това е характерно за DFS.",
                    "isCorrect": false
                }, {
                    "text": "Решение на определена дълбочина.",
                    "rationale": "Това е целта на DLS.",
                    "isCorrect": false
                }],
                "hint": "Името 'Uniform Cost' (равномерна цена) подсказва, че цената е основният водещ фактор."
            }, {
                "questionNumber": 15,
                "question": "UCS може да се разглежда като обобщение на кой друг алгоритъм?",
                "answerOptions": [{
                    "text": "DFS",
                    "rationale": "DFS и UCS имат много различна стратегия на обхождане (дълбочина срещу цена).",
                    "isCorrect": false
                }, {
                    "text": "BFS",
                    "rationale": "Ако всички цени на стъпките са равни, UCS се държи точно като BFS.",
                    "isCorrect": true
                }, {
                    "text": "DLS",
                    "rationale": "DLS е ограничена версия на DFS, не е свързан с UCS.",
                    "isCorrect": false
                }, {
                    "text": "IDS",
                    "rationale": "IDS е итеративна версия на DLS, не е свързан с UCS.",
                    "isCorrect": false
                }],
                "hint": "Помислете какво се случва с приоритетната опашка на UCS, ако всички елементи имат еднакъв приоритет."
            }, {
                "questionNumber": 16,
                "question": "Какъв проблем решава Depth-Limited Search (DLS) в сравнение с обикновения DFS?",
                "answerOptions": [{
                    "text": "Проблема с високата пространствена сложност.",
                    "rationale": "DLS има същата добра пространствена сложност като DFS.",
                    "isCorrect": false
                }, {
                    "text": "Проблема с неоптималните решения.",
                    "rationale": "DLS, също като DFS, не е оптимален.",
                    "isCorrect": false
                }, {
                    "text": "Проблема с безкрайните клонове.",
                    "rationale": "Чрез въвеждането на лимит на дълбочината, DLS избягва безкрайното задълбочаване.",
                    "isCorrect": true
                }, {
                    "text": "Проблема с високата времева сложност.",
                    "rationale": "Времевата сложност все още може да бъде висока до зададения лимит.",
                    "isCorrect": false
                }],
                "hint": "Какво ограничение въвежда DLS, което липсва при DFS?"
            }, {
                "questionNumber": 17,
                "question": "Кой е основният недостатък на DLS?",
                "answerOptions": [{
                    "text": "Много е сложен за имплементация.",
                    "rationale": "Имплементацията е почти същата като на DFS, с добавена проверка за дълбочина.",
                    "isCorrect": false
                }, {
                    "text": "Не е пълен, ако лимитът на дълбочина 'l' е по-малък от дълбочината на решението 'd'.",
                    "rationale": "Ако решението е по-дълбоко от зададения лимит, DLS никога няма да го намери.",
                    "isCorrect": true
                }, {
                    "text": "Винаги е по-бавен от DFS.",
                    "rationale": "Може да бъде по-бърз, ако избегне дълъг, грешен клон.",
                    "isCorrect": false
                }, {
                    "text": "Използва прекалено много памет.",
                    "rationale": "Той е ефективен по отношение на паметта, точно както DFS.",
                    "isCorrect": false
                }],
                "hint": "Какво се случва, ако сте задали търсене до 5-то ниво, а решението е на 6-то?"
            }, {
                "questionNumber": 18,
                "question": "Кои две стратегии комбинира Iterative Deepening Search (IDS)?",
                "answerOptions": [{
                    "text": "BFS и UCS",
                    "rationale": "Тези два алгоритъма са свързани, но IDS не използва UCS.",
                    "isCorrect": false
                }, {
                    "text": "Най-доброто от BFS (пълнота, оптималност) и DFS (ниска пространствена сложност).",
                    "rationale": "IDS постига предимствата на BFS, докато използва итеративен DFS-подобен подход.",
                    "isCorrect": true
                }, {
                    "text": "Локално и глобално търсене.",
                    "rationale": "IDS е стратегия за глобално търсене.",
                    "isCorrect": false
                }, {
                    "text": "UCS и DLS",
                    "rationale": "IDS използва DLS, но не и UCS.",
                    "isCorrect": false
                }],
                "hint": "IDS се опитва да вземе предимствата на търсенето на ширина и търсенето в дълбочина."
            }, {
                "questionNumber": 19,
                "question": "Какъв е основният компромис при IDS?",
                "answerOptions": [{
                    "text": "Губи оптималността на BFS.",
                    "rationale": "IDS е оптимален при същите условия като BFS (еднаква цена на стъпките).",
                    "isCorrect": false
                }, {
                    "text": "Има лоша пространствена сложност.",
                    "rationale": "Напротив, пространствената му сложност е голямо предимство.",
                    "isCorrect": false
                }, {
                    "text": "Многократно обхожда възлите от по-горните нива.",
                    "rationale": "Въпреки че това изглежда неефективно, по-голямата част от работата е на последното ниво, така че повторението не е толкова скъпо.",
                    "isCorrect": true
                }, {
                    "text": "Не е пълен.",
                    "rationale": "IDS е пълен.",
                    "isCorrect": false
                }],
                "hint": "Помислете какво прави алгоритъмът на всяка итерация с възлите, които вече е посетил."
            }, {
                "questionNumber": 20,
                "question": "Времевата сложност на IDS O(b^d) е същата като на кой друг алгоритъм?",
                "answerOptions": [{
                    "text": "DFS",
                    "rationale": "Времевата сложност на DFS е O(b^m), което може да е много по-голямо от O(b^d).",
                    "isCorrect": false
                }, {
                    "text": "BFS",
                    "rationale": "Въпреки че изглеждат различно (O(b^d) срещу O(b^(d+1))), те са асимптотично сходни и описват обхождането на приблизително същия брой възли.",
                    "isCorrect": true
                }, {
                    "text": "UCS",
                    "rationale": "Сложността на UCS зависи от цената на решението, а не от дълбочината.",
                    "isCorrect": false
                }, {
                    "text": "DLS",
                    "rationale": "Сложността на DLS е O(b^l), където 'l' е зададеният лимит.",
                    "isCorrect": false
                }],
                "hint": "Сравнете броя на генерираните възли в най-лошия случай."
            }, {
                "questionNumber": 21,
                "question": "Какво е 'евристика' (heuristic) в контекста на информираното търсене?",
                "answerOptions": [{
                    "text": "Гарантиран начин за намиране на най-краткия път.",
                    "rationale": "Евристиката не дава гаранции, тя е само предположение.",
                    "isCorrect": false
                }, {
                    "text": "Точната цена за достигане до целта.",
                    "rationale": "Ако знаехме точната цена, нямаше да има нужда от търсене.",
                    "isCorrect": false
                }, {
                    "text": "Оценъчна функция, която предполага колко 'близо' е дадено състояние до целта.",
                    "rationale": "Тя предоставя информирано предположение, което насочва търсенето в обещаващи посоки.",
                    "isCorrect": true
                }, {
                    "text": "Набор от правила, които не могат да бъдат нарушени.",
                    "rationale": "Това по-скоро описва функцията-наследник.",
                    "isCorrect": false
                }],
                "hint": "Това е вид 'информирано предположение' или 'правило на палеца'."
            }, {
                "questionNumber": 22,
                "question": "Кой алгоритъм за информирано търсене разширява възела, който изглежда най-близо до целта, без да се интересува от изминатия път?",
                "answerOptions": [{
                    "text": "A* Search",
                    "rationale": "A* взема предвид както изминатия път (g(n)), така и евристиката (h(n)).",
                    "isCorrect": false
                }, {
                    "text": "Greedy Best-First Search",
                    "rationale": "Този алгоритъм е 'алчен', защото се опитва да стигне до целта възможно най-бързо, ръководейки се само от евристичната оценка h(n).",
                    "isCorrect": true
                }, {
                    "text": "Uniform-Cost Search",
                    "rationale": "UCS е неинформиран и се ръководи само от цената на изминатия път.",
                    "isCorrect": false
                }, {
                    "text": "Hill Climbing",
                    "rationale": "Hill Climbing е алгоритъм за локално търсене, не за глобално.",
                    "isCorrect": false
                }],
                "hint": "Помислете за думата 'Greedy' (алчен) - какво означава тя в този контекст?"
            }, {
                "questionNumber": 23,
                "question": "Какво представлява оценъчната функция f(n) в алгоритъма A*?",
                "answerOptions": [{
                    "text": "f(n) = g(n) - h(n)",
                    "rationale": "Формулата използва събиране, а не изваждане, за да балансира двата фактора.",
                    "isCorrect": false
                }, {
                    "text": "f(n) = h(n)",
                    "rationale": "Това е оценъчната функция за Greedy Best-First Search.",
                    "isCorrect": false
                }, {
                    "text": "f(n) = g(n)",
                    "rationale": "Това е оценъчната функция за Uniform-Cost Search.",
                    "isCorrect": false
                }, {
                    "text": "f(n) = g(n) + h(n)",
                    "rationale": "A* комбинира реалната цена досега g(n) с предполагаемата цена до края h(n).",
                    "isCorrect": true
                }],
                "hint": "A* балансира цената на миналото и предполагаемата цена на бъдещето."
            }, {
                "questionNumber": 24,
                "question": "Какво означава евристиката h(n) да е 'допустима' (admissible)?",
                "answerOptions": [{
                    "text": "Че винаги намира решение.",
                    "rationale": "Допустимостта е свойство на функцията, не гаранция за намиране на решение.",
                    "isCorrect": false
                }, {
                    "text": "Че никога не надценява реалната цена за достигане на целта.",
                    "rationale": "Това е ключовото условие, което гарантира оптималността на A*. Евристиката трябва да е 'оптимистична'.",
                    "isCorrect": true
                }, {
                    "text": "Че изчисляването й е много бързо.",
                    "rationale": "Бързото изчисление е желателно, но не е това, което я прави допустима.",
                    "isCorrect": false
                }, {
                    "text": "Че винаги е по-голяма от реалната цена.",
                    "rationale": "Това би направило евристиката недопустима и може да доведе до неоптимални решения.",
                    "isCorrect": false
                }],
                "hint": "Помислете за евристиката като за оптимистично предположение."
            }, {
                "questionNumber": 25,
                "question": "При условие, че се използва допустима евристика, какво е гарантирано за A* търсенето?",
                "answerOptions": [{
                    "text": "Че ще бъде по-бързо от BFS.",
                    "rationale": "Не е задължително; в най-лошия случай може да изследва същия брой възли.",
                    "isCorrect": false
                }, {
                    "text": "Че ще използва по-малко памет от DFS.",
                    "rationale": "A*, подобно на BFS и UCS, може да изисква много памет.",
                    "isCorrect": false
                }, {
                    "text": "Че е пълно и оптимално.",
                    "rationale": "Това са двете основни предимства на A* при правилните условия.",
                    "isCorrect": true
                }, {
                    "text": "Че ще намери решение без да се връща назад (backtracking).",
                    "rationale": "A* е алгоритъм за търсене в граф и може да се наложи да изследва различни пътища.",
                    "isCorrect": false
                }],
                "hint": "Какви са двете най-важни свойства, които търсим в един добър алгоритъм за намиране на път?"
            }, {
                "questionNumber": 26,
                "question": "Кой е основният проблем на алгоритмите за локално търсене като Hill Climbing?",
                "answerOptions": [{
                    "text": "Използват твърде много памет.",
                    "rationale": "Напротив, те са изключително ефективни по отношение на паметта, тъй като пазят само текущото състояние.",
                    "isCorrect": false
                }, {
                    "text": "Засядане в локални оптимуми.",
                    "rationale": "Алгоритъмът може да достигне 'връх', който не е най-високият в цялото пространство, и да не може да продължи.",
                    "isCorrect": true
                }, {
                    "text": "Много бавна скорост на работа.",
                    "rationale": "Те обикновено са много бързи.",
                    "isCorrect": false
                }, {
                    "text": "Не могат да се справят със сложни пространства на състоянията.",
                    "rationale": "Те са създадени точно за сложни пространства, където глобалното търсене е невъзможно.",
                    "isCorrect": false
                }],
                "hint": "Какво се случва, когато алгоритъмът стигне до връх, от който всяка стъпка води надолу, но това не е най-високият връх?"
            }, {
                "questionNumber": 27,
                "question": "Каква е основната идея на Simulated Annealing (симулирано закаляване)?",
                "answerOptions": [{
                    "text": "Винаги да се избира най-добрият съседен ход.",
                    "rationale": "Това е стратегията на Hill Climbing.",
                    "isCorrect": false
                }, {
                    "text": "Да се изследват всички възможни състояния.",
                    "rationale": "Това е характерно за глобалното търсене, не за локалното.",
                    "isCorrect": false
                }, {
                    "text": "Да се позволяват случайни 'лоши' ходове, за да се избягат от локални оптимуми.",
                    "rationale": "Чрез контролирано приемане на по-лоши решения (особено в началото), алгоритъмът може да изследва по-голяма част от пространството.",
                    "isCorrect": true
                }, {
                    "text": "Да се комбинират няколко решения, за да се създаде ново.",
                    "rationale": "Това е основната идея на генетичните алгоритми.",
                    "isCorrect": false
                }],
                "hint": "Алгоритъмът е вдъхновен от процеса на закаляване на метали, който включва контролирано охлаждане."
            }, {
                "questionNumber": 28,
                "question": "Кой от изброените неинформирани алгоритми е пълен и оптимален, когато цената на пътя е от значение?",
                "answerOptions": [{
                    "text": "BFS",
                    "rationale": "BFS е оптимален само ако цените на стъпките са равни.",
                    "isCorrect": false
                }, {
                    "text": "DFS",
                    "rationale": "DFS не е нито пълен (в общия случай), нито оптимален.",
                    "isCorrect": false
                }, {
                    "text": "IDS",
                    "rationale": "IDS е оптимален само ако цените на стъпките са равни.",
                    "isCorrect": false
                }, {
                    "text": "UCS",
                    "rationale": "UCS е специално проектиран да намира пътя с най-ниска цена и е гарантирано пълен и оптимален.",
                    "isCorrect": true
                }],
                "hint": "Търсим алгоритъм, чиято основна цел е минимизиране на общата цена."
            }, {
                "questionNumber": 29,
                "question": "Ако факторът на разклоняване 'b' е много голям, кой от следните алгоритми ще има най-големи проблеми с паметта?",
                "answerOptions": [{
                    "text": "DFS",
                    "rationale": "Пространствената сложност на DFS (O(b*m)) се влияе линейно от 'b', което е по-добре от експоненциалното влияние.",
                    "isCorrect": false
                }, {
                    "text": "BFS",
                    "rationale": "Пространствената сложност на BFS (O(b^d)) е експоненциална спрямо 'b' и 'd', което го прави много чувствителен към голям фактор на разклоняване.",
                    "isCorrect": true
                }, {
                    "text": "DLS",
                    "rationale": "DLS, подобно на DFS, има линейна зависимост на паметта от 'b'.",
                    "isCorrect": false
                }, {
                    "text": "IDS",
                    "rationale": "IDS има същата добра пространствена сложност като DFS.",
                    "isCorrect": false
                }],
                "hint": "Чия пространствена сложност расте експоненциално?"
            }, {
                "questionNumber": 30,
                "question": "Какво е решението на даден проблем за търсене?",
                "answerOptions": [{
                    "text": "Целевото състояние.",
                    "rationale": "Целевото състояние е крайната точка, но не и целият процес.",
                    "isCorrect": false
                }, {
                    "text": "Последователността от действия от началното до целевото състояние.",
                    "rationale": "Решението е пътят, а не само дестинацията.",
                    "isCorrect": true
                }, {
                    "text": "Най-ниската възможна цена на пътя.",
                    "rationale": "Това е характеристика на оптималното решение, но не е самото решение.",
                    "isCorrect": false
                }, {
                    "text": "Всички междинни състояния.",
                    "rationale": "Междинните състояния са част от пътя, но решението е последователността от действия, които водят през тях.",
                    "isCorrect": false
                }],
                "hint": "Решението е рецептата, а не само крайният резултат."
            }, {
                "questionNumber": 31,
                "question": "Времевата сложност на даден алгоритъм се измерва чрез:",
                "answerOptions": [{
                    "text": "Максималния брой възли, пазени в паметта.",
                    "rationale": "Това описва пространствената сложност.",
                    "isCorrect": false
                }, {
                    "text": "Реалното време в секунди за изпълнение на кода.",
                    "rationale": "Реалното време зависи от хардуера; сложността е теоретична мярка.",
                    "isCorrect": false
                }, {
                    "text": "Общия брой възли, които алгоритъмът генерира или проверява.",
                    "rationale": "Това е стандартната мярка за 'работа', извършена от алгоритъма.",
                    "isCorrect": true
                }, {
                    "text": "Дължината на намерения път.",
                    "rationale": "Дължината на пътя е свързана със сложността, но не е самата мярка за нея.",
                    "isCorrect": false
                }],
                "hint": "Как измерваме 'колко работа' върши алгоритъмът, независимо от компютъра, на който работи?"
            }, {
                "questionNumber": 32,
                "question": "Коя от следните двойки алгоритми има най-добра пространствена сложност (O(b*d))?",
                "answerOptions": [{
                    "text": "BFS и UCS",
                    "rationale": "Тези алгоритми имат експоненциална пространствена сложност.",
                    "isCorrect": false
                }, {
                    "text": "DFS и IDS",
                    "rationale": "И двата алгоритъма трябва да пазят в паметта само текущия път, което води до линейна пространствена сложност.",
                    "isCorrect": true
                }, {
                    "text": "BFS и IDS",
                    "rationale": "BFS има експоненциална пространствена сложност, докато IDS има линейна.",
                    "isCorrect": false
                }, {
                    "text": "A* и UCS",
                    "rationale": "В най-лошия случай и двата могат да имат експоненциална пространствена сложност.",
                    "isCorrect": false
                }],
                "hint": "Търсим алгоритми, които не трябва да пазят цели нива от дървото в паметта."
            }, {
                "questionNumber": 33,
                "question": "Защо Greedy Best-First Search не е оптимален?",
                "answerOptions": [{
                    "text": "Защото не е пълен.",
                    "rationale": "Той може да бъде непълен, но причината за неоптималността е друга.",
                    "isCorrect": false
                }, {
                    "text": "Защото игнорира цената на вече изминатия път (g(n)).",
                    "rationale": "Един 'алчен' избор, който изглежда добър сега, може да доведе до много скъп път в бъдеще.",
                    "isCorrect": true
                }, {
                    "text": "Защото използва твърде много памет.",
                    "rationale": "Проблемът му не е в паметта, а в качеството на решението.",
                    "isCorrect": false
                }, {
                    "text": "Защото евристиката му винаги е грешна.",
                    "rationale": "Евристиката може да е добра, но стратегията за нейното използване е 'късогледа'.",
                    "isCorrect": false
                }],
                "hint": "Какво важна част от информацията пренебрегва този 'алчен' алгоритъм?"
            }, {
                "questionNumber": 34,
                "question": "Ако имаме граф с цикли, кой алгоритъм е най-вероятно да влезе в безкраен цикъл, ако не се проверява за посетени възли?",
                "answerOptions": [{
                    "text": "BFS",
                    "rationale": "BFS ще продължи да добавя едни и същи възли в опашката, но няма да се задълбочи безкрайно в един цикъл.",
                    "isCorrect": false
                }, {
                    "text": "DFS",
                    "rationale": "DFS ще следва пътя на цикъла отново и отново, задълбочавайки се безкрайно.",
                    "isCorrect": true
                }, {
                    "text": "UCS",
                    "rationale": "UCS обикновено се справя с цикли, ако цените са положителни, тъй като пътят през цикъла ще стане по-скъп.",
                    "isCorrect": false
                }, {
                    "text": "IDS",
                    "rationale": "IDS е защитен от безкрайни цикли поради лимита на дълбочината.",
                    "isCorrect": false
                }],
                "hint": "Кой алгоритъм има тенденция да следва един път до самия му край?"
            }, {
                "questionNumber": 35,
                "question": "Какво се случва в алгоритъма Hill Climbing, когато достигне 'плато' (plateau)?",
                "answerOptions": [{
                    "text": "Алгоритъмът прекратява работа и връща най-доброто намерено решение.",
                    "rationale": "На плато всички съседи имат същата стойност, което кара алгоритъма да спре, тъй като не може да намери подобрение.",
                    "isCorrect": true
                }, {
                    "text": "Алгоритъмът прави случаен скок до друга част на пространството.",
                    "rationale": "Това е стратегия за рестартиране, но не е част от основния алгоритъм.",
                    "isCorrect": false
                }, {
                    "text": "Алгоритъмът започва да се връща назад (backtracking).",
                    "rationale": "Hill Climbing не пази история на пътя и не може да се връща назад.",
                    "isCorrect": false
                }, {
                    "text": "Алгоритъмът намалява фактора на разклоняване.",
                    "rationale": "Hill Climbing не работи с фактор на разклоняване по начина, по който го правят алгоритмите за глобално търсене.",
                    "isCorrect": false
                }],
                "hint": "Платото е равна област, където няма ясна посока 'нагоре'."
            }, {
                "questionNumber": 36,
                "question": "Кой от следните алгоритми НЕ гарантира пълнота, дори ако съществува решение?",
                "answerOptions": [{
                    "text": "BFS",
                    "rationale": "BFS е пълен.",
                    "isCorrect": false
                }, {
                    "text": "A*",
                    "rationale": "A* е пълен при определени условия.",
                    "isCorrect": false
                }, {
                    "text": "DFS (в графи с безкрайни пътища)",
                    "rationale": "DFS е класически пример за непълен алгоритъм в общия случай.",
                    "isCorrect": true
                }, {
                    "text": "IDS",
                    "rationale": "IDS е пълен.",
                    "isCorrect": false
                }],
                "hint": "Помислете кой алгоритъм може да се 'загуби' и никога да не провери други части на пространството."
            }, {
                "questionNumber": 37,
                "question": "Кога DLS би бил по-добър избор от DFS?",
                "answerOptions": [{
                    "text": "Когато знаем, че решението е много дълбоко.",
                    "rationale": "В този случай може да се наложи да зададем много голям лимит, което обезсмисля DLS.",
                    "isCorrect": false
                }, {
                    "text": "Когато пространството за търсене има много дълги или безкрайни пътища.",
                    "rationale": "Лимитът на DLS ще предотврати безкрайното задълбочаване, което е основен проблем за DFS.",
                    "isCorrect": true
                }, {
                    "text": "Когато се изисква оптимално решение.",
                    "rationale": "Нито DLS, нито DFS са оптимални.",
                    "isCorrect": false
                }, {
                    "text": "Когато паметта не е ограничение.",
                    "rationale": "И двата алгоритъма са добри по отношение на паметта.",
                    "isCorrect": false
                }],
                "hint": "Каква е основната разлика, която DLS въвежда спрямо DFS?"
            }, {
                "questionNumber": 38,
                "question": "Ако h(n) = 0 за всички възли n, на кой алгоритъм ще заприлича A*?",
                "answerOptions": [{
                    "text": "DFS",
                    "rationale": "При h(n)=0, f(n) = g(n), което не е свързано със стратегията на DFS.",
                    "isCorrect": false
                }, {
                    "text": "BFS",
                    "rationale": "Това е вярно само ако всички цени на стъпките са 1. В общия случай, това не е вярно.",
                    "isCorrect": false
                }, {
                    "text": "UCS",
                    "rationale": "При h(n)=0, оценъчната функция става f(n) = g(n), което е точно критерият за разширяване на UCS.",
                    "isCorrect": true
                }, {
                    "text": "Greedy Best-First Search",
                    "rationale": "Greedy търсенето ще спре, тъй като няма да има евристика, която да го води.",
                    "isCorrect": false
                }],
                "hint": "Какво остава от формулата f(n) = g(n) + h(n), ако h(n) е нула?"
            }, {
                "questionNumber": 39,
                "question": "Целта на локалното търсене е да:",
                "answerOptions": [{
                    "text": "Намери път от началото до края.",
                    "rationale": "Това е целта на глобалното търсене.",
                    "isCorrect": false
                }, {
                    "text": "Оптимизира дадена обективна функция чрез малки локални промени.",
                    "rationale": "То се фокусира върху намирането на състояние с максимална или минимална стойност.",
                    "isCorrect": true
                }, {
                    "text": "Да изследва систематично цялото пространство на състоянията.",
                    "rationale": "Това е характеристика на пълните алгоритми за глобално търсене.",
                    "isCorrect": false
                }, {
                    "text": "Да гарантира намирането на глобалния оптимум.",
                    "rationale": "Това е целта, но не е гарантирано поради проблема с локалните оптимуми.",
                    "isCorrect": false
                }],
                "hint": "Локалното търсене не се интересува от историята, а от подобряването на текущата ситуация."
            }, {
                "questionNumber": 40,
                "question": "Пространствената сложност на BFS се дава с O(b^(d+1)). Защо е 'd+1', а не просто 'd'?",
                "answerOptions": [{
                    "text": "Защото трябва да се пази и коренният възел.",
                    "rationale": "Коренният възел е само един, това не би променило експонентата.",
                    "isCorrect": false
                }, {
                    "text": "Това е просто математическа конвенция без практическо значение.",
                    "rationale": "Има конкретна причина за това.",
                    "isCorrect": false
                }, {
                    "text": "Защото в най-лошия случай, преди да се намери решение на ниво 'd', алгоритъмът вече е генерирал всички възли на ниво 'd+1'.",
                    "rationale": "За да завърши изследването на ниво 'd', BFS трябва да постави всички техни наследници (на ниво d+1) в опашката.",
                    "isCorrect": true
                }, {
                    "text": "Защото 'd' е броят на ребрата, а 'd+1' е броят на възлите.",
                    "rationale": "Това може да е вярно за един път, но не обяснява сложността на целия алгоритъм.",
                    "isCorrect": false
                }],
                "hint": "Помислете какво се намира в опашката в момента, в който алгоритъмът е напът да открие решението."
            }, {
                "questionNumber": 41,
                "question": "Кой алгоритъм е най-подходящ, ако паметта е силно ограничена, но знаем, че решението не е твърде дълбоко?",
                "answerOptions": [{
                    "text": "BFS",
                    "rationale": "BFS има високи изисквания за памет.",
                    "isCorrect": false
                }, {
                    "text": "UCS",
                    "rationale": "UCS също може да има високи изисквания за памет.",
                    "isCorrect": false
                }, {
                    "text": "A*",
                    "rationale": "A* също може да има високи изисквания за памет.",
                    "isCorrect": false
                }, {
                    "text": "IDS",
                    "rationale": "IDS комбинира ниската нужда от памет на DFS с пълнотата и оптималността на BFS, което го прави идеален за този сценарий.",
                    "isCorrect": true
                }],
                "hint": "Търсим алгоритъм, който е 'пестелив' откъм памет, но все пак намира най-близкото решение."
            }, {
                "questionNumber": 42,
                "question": "Каква е 'цената на пътя'?",
                "answerOptions": [{
                    "text": "Броят на възлите в пространството на състоянията.",
                    "rationale": "Това е размерът на пространството, а не цена на конкретен път.",
                    "isCorrect": false
                }, {
                    "text": "Сумата от цените на отделните действия, съставящи пътя.",
                    "rationale": "Това е кумулативната цена за преминаване от едно състояние в друго по определен маршрут.",
                    "isCorrect": true
                }, {
                    "text": "Времето, необходимо на алгоритъма да намери решение.",
                    "rationale": "Това е времевата сложност.",
                    "isCorrect": false
                }, {
                    "text": "Най-малкият възможен брой стъпки до целта.",
                    "rationale": "Това е дължината на най-краткия път, но не и общата му цена, ако стъпките са с различна тежест.",
                    "isCorrect": false
                }],
                "hint": "Помислете как бихте изчислили общата такса за пътуване по магистрала с няколко платени участъка."
            }, {
                "questionNumber": 43,
                "question": "Кое от следните е пример за проблем за локално търсене?",
                "answerOptions": [{
                    "text": "Намиране на най-краткия път между два града на карта.",
                    "rationale": "Това е класически проблем за глобално търсене на път.",
                    "isCorrect": false
                }, {
                    "text": "Решаване на Судоку.",
                    "rationale": "Това е проблем за удовлетворяване на ограничения (CSP), който обикновено се решава с глобално търсене и връщане назад.",
                    "isCorrect": false
                }, {
                    "text": "Намиране на конфигурация на протеин с минимална енергия.",
                    "rationale": "Тук целта е да се намери оптимално състояние (конфигурация), а не път, което е идеално за локално търсене.",
                    "isCorrect": true
                }, {
                    "text": "Спечелване на игра на шах.",
                    "rationale": "Шахът включва търсене в дърво от ходове, което е вид глобално търсене.",
                    "isCorrect": false
                }],
                "hint": "Търсим проблем, където целта е да се намери най-добрата 'аранжировка' или 'конфигурация', а не последователност от стъпки."
            }, {
                "questionNumber": 44,
                "question": "Какво означава 'терминално състояние' в дърво за търсене?",
                "answerOptions": [{
                    "text": "Винаги е целевото състояние.",
                    "rationale": "Целевото състояние е един вид терминално състояние, но не всички терминални състояния са целеви.",
                    "isCorrect": false
                }, {
                    "text": "Възел, от който не могат да се генерират повече наследници (задънена улица).",
                    "rationale": "Това е лист на дървото, който може да бъде или цел, или състояние, от което няма валидни ходове.",
                    "isCorrect": true
                }, {
                    "text": "Началното състояние.",
                    "rationale": "Началното състояние е коренът, а не терминален възел.",
                    "isCorrect": false
                }, {
                    "text": "Всеки възел, който вече е бил посетен.",
                    "rationale": "Посетените възли са част от историята на търсенето, но не са задължително терминални.",
                    "isCorrect": false
                }],
                "hint": "Помислете за състояние, от което няма къде повече да отидете."
            }, {
                "questionNumber": 45,
                "question": "Ако времевата сложност на даден алгоритъм е O(b^d), какво означава това?",
                "answerOptions": [{
                    "text": "Времето за изпълнение расте линейно с дълбочината на решението.",
                    "rationale": "Това би било O(d). Растежът тук е много по-бърз.",
                    "isCorrect": false
                }, {
                    "text": "Времето за изпълнение расте експоненциално с дълбочината на решението.",
                    "rationale": "Дълбочината 'd' е в степенния показател, което води до експоненциален растеж на броя на възлите.",
                    "isCorrect": true
                }, {
                    "text": "Времето за изпълнение не зависи от фактора на разклоняване 'b'.",
                    "rationale": "Факторът 'b' е основата на степента и има огромно влияние.",
                    "isCorrect": false
                }, {
                    "text": "Алгоритъмът е много ефективен.",
                    "rationale": "Експоненциалната сложност обикновено се счита за неефективна за големи проблеми.",
                    "isCorrect": false
                }],
                "hint": "Помислете за математическата функция y = a^x. Как се променя 'y' с нарастването на 'x'?"
            }, {
                "questionNumber": 46,
                "question": "Кой алгоритъм е най-вероятно да намери решение най-бързо, ако то се намира много 'плитко' в дървото за търсене?",
                "answerOptions": [{
                    "text": "DFS",
                    "rationale": "DFS може първо да изследва много дълъг, грешен клон и да намери плиткото решение последен.",
                    "isCorrect": false
                }, {
                    "text": "BFS",
                    "rationale": "BFS е проектиран да намира най-плиткото решение, тъй като изследва ниво по ниво.",
                    "isCorrect": true
                }, {
                    "text": "UCS",
                    "rationale": "UCS може да бъде привлечен от евтини, но дълбоки пътища, и да пропусне плитко, но по-скъпо решение.",
                    "isCorrect": false
                }, {
                    "text": "A*",
                    "rationale": "A* може да бъде по-бърз, но BFS има гаранция, че ще намери най-плиткото решение първо.",
                    "isCorrect": false
                }],
                "hint": "Кой алгоритъм започва търсенето си, като проверява всички най-близки съседи?"
            }, {
                "questionNumber": 47,
                "question": "Каква е основната разлика в целта на UCS и A*?",
                "answerOptions": [{
                    "text": "UCS е неинформиран, докато A* е информиран.",
                    "rationale": "A* използва евристика (h(n)) за да се насочи към целта, докато UCS разчита само на реалната цена до момента (g(n)).",
                    "isCorrect": true
                }, {
                    "text": "UCS е винаги по-бърз от A*.",
                    "rationale": "Обикновено A* е по-бърз, защото евристиката му помага да избегне изследването на безперспективни пътища.",
                    "isCorrect": false
                }, {
                    "text": "A* намира най-краткия път, а UCS намира най-евтиния.",
                    "rationale": "И двата алгоритъма намират най-евтиния път (оптимални са), но го правят по различен начин.",
                    "isCorrect": false
                }, {
                    "text": "UCS използва опашка, а A* използва стек.",
                    "rationale": "И двата алгоритъма използват приоритетна опашка.",
                    "isCorrect": false
                }],
                "hint": "Каква допълнителна информация използва A*, за да 'предположи' накъде е целта?"
            }, {
                "questionNumber": 48,
                "question": "Кой е един от начините за справяне с проблема с локалните оптимуми в Hill Climbing?",
                "answerOptions": [{
                    "text": "Използване на по-малка стъпка.",
                    "rationale": "Това може да забави алгоритъма, но няма да му помогне да излезе от локален оптимум.",
                    "isCorrect": false
                }, {
                    "text": "Използване на случаен рестарт (random-restart hill climbing).",
                    "rationale": "Чрез стартиране на търсенето от множество случайни начални точки се увеличава шансът да се намери глобалният оптимум.",
                    "isCorrect": true
                }, {
                    "text": "Винаги избиране на първия по-добър съсед.",
                    "rationale": "Това е част от стандартния алгоритъм и не решава проблема.",
                    "isCorrect": false
                }, {
                    "text": "Преминаване към BFS.",
                    "rationale": "Това е смяна на типа търсене от локално към глобално.",
                    "isCorrect": false
                }],
                "hint": "Ако сте заседнали на един хълм, какво може да опитате, за да намерите по-висок?"
            }, {
                "questionNumber": 49,
                "question": "Ако имате проблем, в който цената на всяка стъпка е 1 и искате да намерите най-краткия път с възможно най-малко памет, кой алгоритъм е най-добрият компромис?",
                "answerOptions": [{
                    "text": "BFS",
                    "rationale": "BFS ще намери най-краткия път, но изисква много памет.",
                    "isCorrect": false
                }, {
                    "text": "UCS",
                    "rationale": "При цена 1 UCS ще работи като BFS, което означава, че ще изисква много памет.",
                    "isCorrect": false
                }, {
                    "text": "A*",
                    "rationale": "A* ще бъде оптимален, но също може да изисква много памет.",
                    "isCorrect": false
                }, {
                    "text": "IDS",
                    "rationale": "IDS ще намери най-краткия път (тъй като цената е 1) и има отлична пространствена сложност.",
                    "isCorrect": true
                }],
                "hint": "Търсим алгоритъм, който съчетава оптималността на BFS и ефективността по памет на DFS."
            }, {
                "questionNumber": 50,
                "question": "Каква е ролята на променливата 'm' (max depth) при оценката на DFS?",
                "answerOptions": [{
                    "text": "Тя определя дълбочината на оптималното решение.",
                    "rationale": "Това се описва с променливата 'd'.",
                    "isCorrect": false
                }, {
                    "text": "Тя представлява максималната възможна дълбочина на дървото за търсене.",
                    "rationale": "Тази стойност е важна за времевата сложност на DFS, защото в най-лошия случай алгоритъмът може да се наложи да изследва до тази дълбочина.",
                    "isCorrect": true
                }, {
                    "text": "Тя е свързана само с информираните алгоритми за търсене.",
                    "rationale": "Използва се за анализ на неинформирани алгоритми като DFS.",
                    "isCorrect": false
                }, {
                    "text": "Тя измерва броя на възлите, пазени в паметта.",
                    "rationale": "Това е свързано с пространствената сложност, но 'm' е мярка за дълбочина.",
                    "isCorrect": false
                }],
                "hint": "Тази променлива описва 'дъното' на пространството за търсене."
            }]
        };
        const quizData = quizDataRaw.questions;

        const questionTextElement = document.getElementById('question-text');
        const answerButtonsElement = document.getElementById('answer-buttons');
        const nextButton = document.getElementById('next-btn');
        const restartButton = document.getElementById('restart-btn');
        const rationaleTextElement = document.getElementById('rationale-text');
        
        const quizContainer = document.getElementById('quiz-container');
        const quizHeader = document.getElementById('quiz-header');
        const questionArea = document.getElementById('question-area');
        const feedbackArea = document.getElementById('feedback-area');
        const navigationArea = document.getElementById('navigation-area');
        const resultArea = document.getElementById('result-area');
        const scoreTextElement = document.getElementById('score-text');
        const finalMessageElement = document.getElementById('final-message');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');

        let currentQuestionIndex = 0;
        let score = 0;

        function startQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            resultArea.classList.add('hidden');
            quizHeader.classList.remove('hidden');
            questionArea.classList.remove('hidden');
            feedbackArea.classList.remove('hidden');
            navigationArea.classList.remove('hidden');
            nextButton.classList.add('hidden');
            nextButton.textContent = 'Следващ въпрос';
            showQuestion();
        }

        function showQuestion() {
            resetState();
            const currentQuestion = quizData[currentQuestionIndex];
            const questionNo = currentQuestionIndex + 1;

            questionTextElement.textContent = `${questionNo}. ${currentQuestion.question}`;
            progressText.textContent = `Въпрос ${questionNo} от ${quizData.length}`;
            progressBar.style.width = `${(questionNo / quizData.length) * 100}%`;

            currentQuestion.answerOptions.forEach(answer => {
                const button = document.createElement('button');
                button.textContent = answer.text;
                button.classList.add('answer-btn', 'w-full', 'text-left', 'p-4', 'border-2', 'border-slate-300', 'dark:border-slate-600', 'rounded-lg', 'hover:bg-slate-100', 'dark:hover:bg-slate-700', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500');
                button.dataset.correct = answer.isCorrect;
                button.dataset.rationale = answer.rationale;
                button.addEventListener('click', selectAnswer);
                answerButtonsElement.appendChild(button);
            });
        }

        function resetState() {
            nextButton.classList.add('hidden');
            rationaleTextElement.textContent = '';
            rationaleTextElement.classList.remove('bg-green-100', 'dark:bg-green-900', 'border-green-400', 'bg-red-100', 'dark:bg-red-900', 'border-red-400');
            while (answerButtonsElement.firstChild) {
                answerButtonsElement.removeChild(answerButtonsElement.firstChild);
            }
        }

        function selectAnswer(e) {
            const selectedBtn = e.target;
            const isCorrect = selectedBtn.dataset.correct === 'true';

            if (isCorrect) {
                score++;
                selectedBtn.classList.add('correct');
                rationaleTextElement.classList.add('bg-green-100', 'dark:bg-green-900', 'border-green-400');
            } else {
                selectedBtn.classList.add('incorrect');
                 rationaleTextElement.classList.add('bg-red-100', 'dark:bg-red-900', 'border-red-400');
            }
            
            rationaleTextElement.textContent = selectedBtn.dataset.rationale;

            Array.from(answerButtonsElement.children).forEach(button => {
                if (button.dataset.correct === 'true') {
                    button.classList.add('correct');
                }
                button.disabled = true;
            });

            if (quizData.length > currentQuestionIndex + 1) {
                nextButton.textContent = 'Следващ въпрос';
            } else {
                nextButton.textContent = 'Виж резултатите';
            }
            nextButton.classList.remove('hidden');
        }

        function showResults() {
            quizHeader.classList.add('hidden');
            questionArea.classList.add('hidden');
            feedbackArea.classList.add('hidden');
            navigationArea.classList.add('hidden');
            resultArea.classList.remove('hidden');

            const scorePercent = Math.round((score / quizData.length) * 100);
            scoreTextElement.textContent = `Вашият резултат е ${score} от ${quizData.length} (${scorePercent}%)`;

            let message = '';
            if (scorePercent === 100) {
                message = 'Отлично! Познанията ви са перфектни!';
            } else if (scorePercent >= 80) {
                message = 'Много добре! Разбирате материала в дълбочина.';
            } else if (scorePercent >= 50) {
                message = 'Добър резултат! Имате солидна основа, но може да преговорите някои теми.';
            } else {
                message = 'Не се отчайвайте! Преговорете материала и опитайте отново.';
            }
            finalMessageElement.textContent = message;
        }

        function handleNextButton() {
            currentQuestionIndex++;
            if (currentQuestionIndex < quizData.length) {
                showQuestion();
            } else {
                showResults();
            }
        }

        nextButton.addEventListener('click', handleNextButton);
        restartButton.addEventListener('click', startQuiz);

        startQuiz();
    </script>
</body>
</html>