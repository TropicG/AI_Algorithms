* State space 

	Търсене в пространството на състоянията (state-space search) е често срещан метод в изкуствения интелект за решаване на пъзели или намиране на маршрути 
	
	Имаме няколко състояния (states), в който можем да попаднем в конкретен момент:
	- Начално състояние (S): Стартиращата позиция на входа 
	- Целево състояние (G): Изходът или голът, който желаем да постигнем
	- Междинно състояние: това е всяко състояние, което не е стартовото или крайното 
	
	Функция-наследник или оператор е наборът от правила или възможни ходеве, които могат да се направят от текущото състояние
	
	Цената на пътя е цената да стигнеш от едно състояние до друго
	
	Пространство на състоянията (State Space) е съвкупността от всички възможни места (състояния), до които изобщо може да се стигне, тръгвайки от входа 
	
	Решението на този тип задачи е последователността от действия, която успешно завежда от началното състояние до целевото състояние 
	
* Визуално представяне на пространството от състояния 
	
	Цялото пространство на състоянията се изобразява като граф или дърво, като всяко състояние е възел (node), докато функцията-наследник е ребро.
	
	Когато пространството от състояния е представено като дърво, то е Двоично дърво за търсене (Search Tree):
	- Началното състояние е коренът на дървото
	- Целевото състояние и терминалните състояния (задънените улици) са листата на дървото 
	
* Оценяване на различните алгоритми за търсене 

	Една оценка се прави по четири основни критерии:
	- Пълнота (Completeness): Ще намерили алгоритъма някакво решение, ако изобщо има такова?
	- Оптималност (Optimality): Ще намери ли най-доброто решение (най-краткото или най-евтиното)
	- Времева сложност (Time complexity): Колко бързо работи, това се измерва с общия брой възли, които алгоритъма трябва да провери в най-лошия случай
	- Пространствена сложност (Space Complexit): Колко RAM заема, това се измерва с максималния брой възли, които трябва да пази в паметта си едновременно
	
	За да се измери времето и паметта, се изпозлват три променливи:
	- b (brancing factor): максималния брой нови избори, които има на всяка стъпка 
	- d (depth): колко стъпки е дълбоко най-доброто решение
	- m (max depth): Максимална възможна дълбочина на търсенето 
	
* Global Search vs Local Search 

	Глобално търсене (Global Search) са стретегиите, които разглеждат цялото възможно пространство (всички възможни състояния)
	Ако е необходимо ще се обходи всяка една възможна опция, за да се стигне до решение, защото имат поглед върху всичко 
	
	Локалното търсене гледа само в локална зона за текущото си състояние. Това търсене не знае какво има надалече.
	Ако решението се намира извън тази ясна зона, те няма да могат да го направят 
	
* Local Search 

	Някой от основните моменти на алгоритъма Локално търсене:
	- Това е оптимизиращ алгоритъм, целта му не е просто да намери някакво решение, а да намери най-оптималното решение 
	- Не го интересува пътя, тоест интересува го крайният резултат, а не стъпките за да се стигнат до него 
	- Целта му е максимизиране/минимизиране, тоест използва се за проблеми, където трябва да намериш най-доброто решение сред много кандидати
	- Алгоритама започва от едно решение и прави малки, локални промени като се мести от решение към по-добро решение. Това продължава, докато не намери оптимално решение 
	
* Неинформирани стратегии за търсене (Uninformed Search Strategies)

	Наричат се така, защото разполагат само с най-основната информация за проблема, тоест къде е старта и какви са правилата за възможните ходове
	Те нямат никаква допълнителна насока, която да ги насочи към целта, те само следват твърда, систематична процедура за обхождане, докато не намерят решение 
	
	Има няколко такива:
	- DFS (Depth First Search)
	- BFS (Breadth First Search)
	- UCS (Uniform Cost Search)
	- DLS (Depth Limited Search)
	- IDS (Iterative Deepining Search)
	
* DFS (Depth First Search)

	DFS е стратегия за обхождане на граф или дърво, която изследва максимално дълбоко по един клон, преди да се върне назад (backtracking).
	При разширяване на възел, алгоритъма избира един от наследниците му и продължава рекурсивно надолу, едва след като се изчерпи един цял клон, алгоритъма се връща към родителския възел
	и избира следващия непроверен наследник
	
	За реазизация на това се използва Stack, когато един възел се разшири, неговите наследници се добавят в стека, следващия възел, който се обработва е винаги този, който е най-отгоре в стека 
	
	Оценка на стратегията:
	- Пълнота (Completeness): Не, защото ако попадне в безкраен клон, алгоритъма ще продължи да се задълбочава вечно и никога няма да се върне, за да намери решение, което може да съществува в друг клон
	Пълен е само за крайни пространства без цикли 
	
	- Оптималност (Optimal): Не, понеже DFS намира само първото решение, на което попада. Това решение, не е задължително да бъде оптимално 
	
	- Времева сложност (Time Complexity): О(b^m), защото най-лошият сценарии е когато решението е на най-последния клон, който алгоритъма проверява 
	- Пространствена сложност (Space Complexity): O(b*m), защото трябва да се провери всеки един клон и неговите наследници 
	
	
	Виж DFSExample.java
	
* BFS (Breadth First Search)

	Това е стратегия, която работи, като изследва ниво по ниво. 
	Използваната структура за този алгоритъм е Queue, която е структура от тип FIFO (First In First Out), когато посетиш един връх добавяш всички негови деца в края на опашката, а алгоритъма взима
	следващия възел от началото на опашката, именно това гарантира обхождане ниво по ниво 
	
	Оценка на стратегията:
	- Пълнота: Да, защото търси ниво по ниво, тоес никога не може да се загубим в безкраен дълбок клон. Ако има решение то BFS ще го намери 
	- Оптимален: Да, но само ако цената е еднаква за всяка стъпка. BFS намира най-плиткото решение (това с най-малко стъпки d), защото ако всички стъпки са с една цена и решението ще е най-оптималното
	- Времева сложност: О(b ^ (d + 1)), защото в най-лошия случай BFS трябва да посети всички върхое на всички нива до d (това е много бавно)
	- Пространствена сложност: О(b ^ (d + 1)), защото за да приклчи с дадено ниво d, алгоритъма трябва да държи в паметта всички възли до следващото ниво 
	
	Виж BFSExample.java
	
* UCS (Uniform Cost Search)

	Това е статегия, която е подобна на BFS, но вместо да търси най-плиткия път (най-малко стъпки), UCS намира най-евтиния път (с най-ниска обща цена)
	Структурата от данни, която се използва, за да реализира този алгоритъм е Priority Queue, вместо нормална опашка за BFS.
	Именно тази структура от данни избутва най-отпред най-евтиния път, по който ще поеме алгоритъма 
	
	Оценка на статегията:
	- Пълнота: Да, понеже винаги намира най-евтиния път, той гарантирано ще намери решението, ако съществува 
	- Оптимален: Да, защото това му е основната цел, понеже UCS винаги избира най-евтиния път от всяко състояние към следващото 
	- Времева и пространствена сложност: O(b ^ (1 + C*/ε))
	Тук C* е цената на оптималното решение, а епсилон е минималната възможна цена на една стъпка. ($C^*/\epsilon$ всъщност представлява "дълбочината" или броя "ценови нива", които алгоритъмът трябва да изследва.)
	Времето и паметта растат експоненциално спрямо цената ан решението, което е много. UCS трябва да държи голям брой върхове в една priority queue опашка 
	
* DLS (Depth Limited Search)

	Общо взето този алгоритъм е DFS, на който му е зададен лимит до колко дълбочина може да итерира 
	С други думи алгоритъма работи като DFS, но спира и се връща назад щом стигне зададената дълбочина l, всичко от дълбочина l нататък се третира като задъдени улици 
	
	Оценка на стратегията:
	- Пълен: Да, но само ако лимита l е достатъчно голям, че да достигне решение
	- Оптимален: Не, точно както DFS, той ще намери първото решение, на което попадне, а не най-оптималното 
	- Времева сложност: O(b^l), също както DFS само че l е заменено с m, в най-лошия случай алгоритъма обхожда всички възли до ниво l
	- Пространствена сложност: О(b * l), нуждата от памет е пропорционална на дълбочината на търсене, която тук е ограничена до l 

	Виж DLSExample.java
	
* IDS (Iterative Deepining Search)

	Това е стратегия, която взима най-доброто от DFS и BFS:
	- Пълнотата и отпималността на BFS
	- Ниската пространствена сложност на DFS 
	
	Алгоритъма представлява цикличното изпълнение на DLS отновно и отново, като всеки път се увеличава лимита l с 1
	Първо се изпълнява DLS с лимит l, ако не се намери решение се изпълнява DLS с лимит l + 1 и така докато не се намери решение с дълбочина l = d 
	
	Оценка на стратегията:
	- Пълен: Да, защото не може да се загуби в безкраен клон, защото имаме лимитиращо условие l 
	- Оптимален: Да, ако цената на стъпката е винаги 1ца, в такъв случай винаги ще се намери оптималното решение 
	- Времева сложност: О(b^d), защото по-голямата част от работата се намира на последните нива d 
	- Пространствена сложност: О(b * d), защото максималната нужда за памет е за всичките върхове и техните разклонения
	
	
	
	
	