* Преговр на Неинформираните търсения (Uninformed Search)

    Критерия за оценка на алгоритмите:
    - Пълнота (Completeness): Дали алгоритъма винаги ще намери решение, ако такова съществува?
    - Оптималност (Optimality): Дали винаги ще намери най-доброто (най-евтиновот) решение?
    - Времева сложност (Time complexity): Колко време отнема?
    - Пространствена сложност (Space complexity): Колко памет използва?
    
    Променливи за измерване на сложността:
    - b (branching factor): Максималния брой възможни ходове от едно състояние 
    - d (depth): Дълбочината (броят стъпки) до най-доброто решение 
    - m (max depth): Максималната дълбочина на цялото пространство за търсене

    Основни видове търсения:
    - Неинформирано търсене (Uninformed Search): Алгоритмите разполагат само с дефиниция на проблема (тоест goal state-a) без никаква подсказва накъде е по-добре.
    - Информирано търсене (Informed Search): Алгоритмите използват евристика (heuristic), тоест фунцкия, която прави предпложение колко "близо" е дадено състояние до целта.

    Примери за информирани алгоритми:
    - Greedy
    - Hill Climbing
    - A* 

* Heuristic function (евристика)

    Евристиката е специална функция, която прави интелигентно предположение към кое състояние да продължи, и се отбелязва с h(n)
    Взима текущото състояние n и оценява колко далеч е то от goal state-a

    Функцията позволява на алгоритъма да бъде информиран, тоест вместо да проверява всички възможни пътища на сляпо, алгоритъма предпочита да изследва тези състоя, които според евристиката изглеждат по-близо до решението
    Това именно подпомага на алгоритъма да намери целта много по-бързо и с по-малко усилия

* Greedy algorithm (Алчен алгоритъм)

    Greedy алгоритъм-а винаги избира да отиде към състоянието, което изглежда най-близо до крайната цел. Той взима това решение като гледа евристичната стойност (h(n)), тоест предполагаемото разстояние до целта.
    Greedy алгортиъма също игнорира колко път (тоест цената) е изминал до момента 

    Основни характеристики:
    - Пълен: Не, защото има възможност да зацикли в безкрайна пътека (ако пространството е безкрайно) или да се върти в кръг (ако не проверява за повторно състояние) и така никога няма да намери решение
    - Оптимален: Не, понеже гледа само следващата стъпка, често може да бъде подведен. Намира някакво решение, но почни никога не намира найд-доброто решение
    - Времева и пространствена сложност: О(b^m), в най-лошия случай алгоритъма може да се наложи да претърси цялото пространство, точно както DFS, освен това пази всички възли в паметта, което отнема много място 

    Виж GreedyExample.java

* Beam Search 

    Beam Search е буквално Greedy алгоритъма, който е оптимизиран за памет, тоест той има лимит l от Node-овете, които може да приеме 

    Ключови характеристики:
    - Оптимален: Не, защото алгоритъма изхвърля пътища на всяка стъпка и лесно може да да се изхвърли най-добрия път, ако той не е изглеждал достатъчно обещаващ в началото
    - Пълен: Не, поради същата причина като Оптималността, ако единствения път до оптималното решение бъде отхвърлено, алгоритъмът никога няма да намери решение 
    - Времева сложност: O(m.b.l) по-бърз е, защото претърсва много по-малко пространство
    - Пространствена сложност: O(b.l), вместо да пази много възли в паметта O(b^M), той пази само ограничен линеен брой възли

    Виж BeamSearchExample.java 

* Hill Climbing 

    Това е най-кратката версия на Beam Search, буквално е като Beam Search просто има l = 1
    Това означава също, че алгоритъма няма никаква памет за минималните си избори

    Неговия процес на работа включва:
    - Намира се в едо единствено текущо състояние 
    - Разглежда всичките си съседи
    - Избира най-добрия съсед (този с най-добра евристика)
    - Забравя за всичко останало и се премества в този нов съсед 
    - Повтаря докато не стигне до целта или не свърши 

    Ключови характеристики:
    - Пълен: Не 
    - Оптимален: Не 
    - Пространствена сложност: О(b), много ефективен за паметта защото пази само текущото състояние, без опашка или история
    - Времева сложност: О(bm), в най-лошия случай може целта да е на максималната възможна дълбочина, а на всеки тези m стъпки, за да провери накъде да отиде, трябва да мине през всичките си съседи

* Hill climbing and Beam Search 

    И двата алгоритъма се счита т за локално търсене
    Те са по-подходящи за оптимизационни задачи (намиране на най-доброто решение чрез постепенно подобряване), отколкото за намиране на път 

* A* 

    A* е един от най-важните и мощни алгоритъма за намиране на път 

    А* е алгоритъм, който намира най-краткия (оптимален) път от старта до целта.
    За разлика от Greedy алгоритъма, който гледа евристичната функция h(n), A* е по-балансиран, като взима предвид две неща:
    - g(n): това е реалната цена, която струва до сегашното състояние
    - h(n): е евристичната цена, която се очаква да се добави като се посети следващото състояние 

    Приоритета на всеки възел се изчислява с формулата f(n) = g(n) + h(n), като f(n) е общата предполагаема цена на целия път, ако той мине през възел n
    А* именно винаги избира да мине през възела с най-малка цена f(n)

    За да може A* гарантирано да намира най-добрия път, неговата евристика h(n) трябва да е "допустима", тоест че евристиката никога не надценява реално разстоянието до целта 

    Ключови характеристики:
    - Пълен: Да, защото винаги намира решение, ако съществува
    - Оптимален: Да, защото гарантирано намира най-добрия (най-евтин) път, ако евристиката h(n) е допустима
    - Времева сложност: О(b^d)
    - Пространствена сложност: О(b^d)

    