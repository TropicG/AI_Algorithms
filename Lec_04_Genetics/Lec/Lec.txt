* Въведение в Genetic Algorithms

    Генетичните алгоритми са техника за търсене и оптимизация, която е вдъхновена от естествнеата еволюция

    Основната идея е да се развива група от решениея, за да се отркие най-доброто, като този процес разчита на три основни биологични принципа:
    - Selection, crossover, and mutation (Подбор, кръстосване и мутация)
    - Целта е да се намери най-доброто/най-пригодното решение чрез еволюиране от възможни такива

    Всяко решение се състои от набор параметри, които са подобни на гените в биологията, за да се оцени колко е добро едно решение, се използва понятието fitness
    # Фитнеса на всеки индивид измерва колко добре той решава конкретния проблем

    Има три основни понятия на тази система:
    - Ген: това е най-малката единица
    # Един параметър или характеристика, която определя част от решението, пример: тегло, стойност или променлива за взимане на решение
    - Хромозома: това е цялостното решение
    # Това е пълния набор от генни, който представлява едно потенциално решение, пример: да кажем някакъв n-tuple [x1,...,xn]
    - Популация: Това е съвкупността от всички решения
    # Група от хромозоми, които представляват много решения, които се тестват едновременно

* Цикъла на работа на един генетичен алгоритъм 

    Цикъла на работа представлява затворен цикъл, който се повтаря, докато не се намери достатъчно добро решение, процеса преминава през следните фази:
    - Начало
    - Еволюционен цикъл
    - Проверка за край
    - Край

    # Начало
    - Initial Population, процесът започва със създаването на първоначална група от случайни решения (хромозоми)
    
    # Еволюционен цикъл
    - Evaluation: всяко решение от популацията се оценява, за да се види колко добре решава проблема (тоест се изчислява неговия fitness score)
    - Selection: на база на оценката се избират най-добрите индивиди, които да станат "родители" на следващото поколение
    - Crossover: избраните родители разменят части от своите гени, за да създадат нови потомци
    - Mutation: случайно се променят малки части от новите решения, това се прави, за да се поддържа разнообразие и алгоритъма да не заседне в едно решение
    - Evolved Population: вече има нова по-добра група от решениея

    # Проверка за край
    - Convergence Check: тук алгоритъма проверява дали е изпълнено условието за край, примерно да е намерено идеалното решение
    # Ако не е намерено решението, отново започва целият процес от Evaluation и целият алгоритъм се повтаря с новата популация
    # Ako е намерено решението алгоритъма приключва и и се връща най-доброто намерено решение

* Selection pressure

    Selection е етапът, в който индивидуалните хромозоми се избират от популацията за последващо размножаване

    Selection pressure се отнася до това колко силно алгоритъма предпочита най-добре представящите се индивиди, още е описано и като (degree of bias towards fitter individuals)

    Има два подхода, когато стане дума за (Selection pressure):
    - Висок селекционен натиск (High seleciton pressure), този подход алгоритъма сикно фаворизира най-добрите
    # +: Води до по-бързо намиране на решение
    # -: Има риск от преждевременна сходимост, тоест че има възможност да се стигне до loss of diversity, such in local optima (загуба на разнообразие и засядане в локален оптимум)
    # С други думи намира се добро решение, но не най-доброто възможно и алгоритъма спир да търси нови вариянти

    - Нисък селекционен натиск (Low selection pressure)
    # +: Позволява по-добро изследване на пространството за търсене и повече генетично разнообразие
    # -: Води до по-бавно намиране на крайното решение
    
    Накратко:
    - Ако има high presusre ще се намира решението бързо, но е възможно да бъде грешно
    - Ако има low pressure ще се изследват много възможности, но ще се отнеме повече време

* Selection by Roulette Wheel

    Това е един от популярните методи за селецкия в генетичните алгоритми: (Selection by Roulette Wheel)

    Работи се на вероятностен принцип, където по-добрите решения имат по-голям шанс да бъдат израбни, тоест хромозомите се избират с вероятност, пропорционална на тяхният fitnes
    Формулата за изчисление на този шанс е: selection probability = (individual fitnes / total fitnes)

    #Причината този метод да се нарича рулетка е защото всяка хромозона може да бъде представена като сектор, който има размер отговарящ на фитнеса, съответно има по-голям шанс индивидите с по-големи сектори да бъдат избрани 

    Предимства:
    - Този метод е описан просто и работи добре, когато разликите в фитнеса са умерени
    
    Недостатък:
    - Освновният риск е (prematura convergence), тоест ако един индивид е изключително пригоден (има гоялм фитнес), това би задушило разнообразието защото рулетката почти винаги ще спира на него

    В генетичните алгоритми обикновенно се използва (sampling with replacement) извадка със замества, защото една и съща хромозона може да бъда избрана многократно
    # Това е важно защото се иска най-добрите родители да създават повече от едно дете в следващото поколение

    Виж RouletteWheelExample.py

* Tournament selection 

    Този метод се предпочита пред "Рулетката" заради простотата си и възможност за лесен контрол

    Идеята е да се симулират малки състезания между случайни участници, вместо да се гледа цялата популация наведнъж се избира случайно малка група от индивиди и се избира най-добрия от тази група да бъде родители

    Ключовият момент тук е размерът на турнира, означек с k, чрез него може да променяме selection pressure:
    - Голямо k, води до stronger selection pressure (more elitists)
    # Ако в турнира участват много хора, шансът най-силният от цялата популация да е вътре е голям, така слабите нямат шанс никога да спечелят

    - Малко k, води до more diversity
    # Ако турнирът е само между двама (примерно слаб и среден), средния ще победи и ще стане родител, това дава шанс и на не най-добрите решения да оцелеят, което запазва разнообразието

    Предимства:
    - Метода е лесен за имплементиране

    Недостатъци:
    - Съществуваме риск от загуба на разнообразие, ако примерно размерът на турнира е твърде голям 

    Виж TournamentBased.py 

* Rank-based selection 

    Основната разлика тук е че игнорираме колко точно е добър един индивид (като числова стойност) и се интересуваме само от това на кое място се класира спрямо другите

    Вместо да се използват директните стойности на фитнес (raw fitness value) индивидите се подреждат в класации 
    Вероятността за селекция зависи от ранга, а не от абсолютната fitnes стойност
    # При Rank-Based един индивид става номер 1 или номер 2

    Предимства:
    - Предотвратява доминирането на едно много пригоден индивид, това също такка поддържа постоянен селекционен натиск, независимо колко големи са разликите в точките
    
    Недостатък:
    - Може да бъде по-бавен в сходимостта, защото намалява разликите между индивидите, най-добрите не изпъкват толкова, колкото при другите методи 

    Начин на работа на алгоритъма:
    - Сортира се популацията базирано на fitness score-a
    - Присвояват се вероятности на базата на поредения номер (ранга), а не на точките
    - Избират се родителите на базата на тези нови вероятности

    Виж RankBasedSelection.py 

* Stochastic Universal Sampling (SUS)

    Този метод е вариация на селекцията чрез рулетка, която осигурява по-равномерно и последователно разпределение на избраните индивиди
    # Основният проблем на обикновенната рулетка е че тя е твърде случайна, дори да има голям сектор програмата може да вземе по-слаба хромозома, но SUS решава този проблем

    Вместо да се върти колелото много пъти (по веднъж за всеки родител) ще се прави следното:
    - вместо едно завърдане ще се поставят множество равномерно разположени стрелки върху нея (равни на броя на родителите)
    - Когато се завърти колелото веднъж всички стрелки избират индивиди едновременно 
    
    Предимства:
    - Намалява фактора късмет
    - Ensures even sampling proportional to fitness

    Недостатъци:
    - Slightly more complex to implement than standart roulette selection (Изисква малко повече усилия при писането на кодa)

    # С други думи, ако рулетката е като да се хвърли зар много пъти, SUS е като да се отреже тора на равни парчета и да се завърти подноса веднъж 

* Elitism

    Правилото гласи, че най-добрите индивиди от текущото поколение се прехвърлят автоматично в следващото поколение, без промяна

    Предимства:
    - Гарантира, че най-добрите решения са запазени
    - Подобрява скоростта на сходимост, понеже се запазват най-добрите черти, алгоритъма стига до решението по-бързо

    Недостатъци:
    - Намалява разнообразието

        