* Проблеми за удовлерворяване на ограничения (CSP - Constraint Satisfaction Problems)

    Един CSP се състои от три неща:
    - Променливи: неща, на които трябва да намерим стойности (например X1, ..., Xn)
    - Домейн: Списък от възможни стойности за всяка променлива
    - Ограничения: Правила, които казват кои комбинации от стойности са позволени 

    Целта при CSP е просто да се намери едно "състояние" (тоест да се присвоят стойности на всички променливи) така, че всички ограничения да са спазени.
    Не се интересува от пътя или от стъпките, за да стигнем до това решение, а само дали то съществува. 

* Граф на ограниченията 

    CSP проблемите често се представят визуално като "граф на ограниченията, където възлите са променливите, а ребрата между тях представляват ограниченията"

    Има няколко вида ограничения:
    - Единични (Unary) ограничения: Те засягат само една променлива, като обикновено не се чертаят в графа, а просто се използват за премахване на стойности от домейна на променливата
    - Двоични (Binary) ограничения: Това са най-често срещаните ограничения, които засягат две променливи, като се представят като стандартни ребра в графа 
    - Ограничения от по-висок ред (Higher-order): Засягат три или повече променливи едновременно
    - Меки (Soft) ограничения: Това са по-скоро предпочитания, а не строги правила, тяйното нарушаване не прави решението невалидно, а просто по-лошо. Те се използват в проблеми за оптимизация на ограниченията

* Как се решава една CSP задача 

    Основният метод се нарича Backtracking като това е вид оптимизирано търсене в дълбочина (DFS) и работи на два принципа:
    - Избира се ред на променливиите и се избират стойности за тях в този ред
    - Избират се само валидни стойности, който не са в конфликс с предишни избрани стойности, ако такава стойност не съществува се bracktrack-va на предишното състояние и се променя стойността.
    
    Най-използваните варианти са:
    - Backtracing (DFS)
    - Constraint Propagation (Разпространение на ограниченията): това са техники, които предсказват проблемите по-рано, като се намлят домейните на други променливи
    Ако дадена променлива е избрала червен цвят, казваме на другите променливи, че те не могат да имат червен цвят (ако примерно всека променлива трябва да има по един цвят)
    Arc consistency е метод, който проверява двойки променливи, за да се увери, че за всяка стойност на едната има поне една съвместима стойност за другата 
    
    - Minimum Remaining Values (MRV): Винаги да се избира да се присвой стойност на променливата, която има най-малко възможни стойности останали в домейна си
    Ако тази променлива се провали, е по-добре да разберем това веднага, вместо да си губим времето с други променливи 

    - Least Constraining Value (LCV): След като се избере променлива с MRV да се избере стойности за нея, която елиминира най-малко възможните от домейните на нейните съседи
    Това дава максимална гъвкавост за бъдеще присвоявания

    - Local Search (minConflict): вместо да се гради решението стъпка по стъпа се започва с пълно, но грешно решение.
    След това многократно избира променлива, която е в конфликт и променя стойността й на тази, която причинява минимален брой нови конфликт.

* Алгоритъма Min-conflicts 

    Алгоритъма Min-Conflicts (Минимални конфликти) е бърз метод (евристика) за решаване на CSP

    Работи по следния начин:
    - Започва се пълно, но случайно (и вероятно грешно) присвояване на стойности на всички променливи
    - След това итеративно (многократно) се повтаря:
        1. Избира се произволна променлива, която е в конфликт (тоест се нарушава някое ограничение)
        2. Променя нейната стойност на тази, която причинява най-малко (минимален брой) нови конфликти с останалите променливи
    - Спира се алгоритъма, когато няма повече конфликти и решението е намерено

* Пример за minConflicts с "4 Царици"

    Пример за този алгоритъм е проблема "N-Queens", където целта е да се поставят N царици на NxN шахматна дъска, така че никоя да не заплашва друга

    h(n) е броят на конфликтите, като целта е h = 0

    Тази примерна задача би минала през следния алгоритъм:
    - В началото (h=5) се започава със случайна подредба, като примерно имаме 5 двойки царици, които се атакуват взаимно
    - Итерация 1 (h=2), алгоритъма примерно избира една от конфклитните царици и я премества в същата колона, но на ред, където тя създава най-малко конфлики
    - Итерация 2 (h=0) алгоритъмът избира една от останалите две конфликтни царици и я премества, като новата позоция решава всички конфликти 

    Накрая решението е намерено, като този метод е много ефективен, особено при големи проблеми, защото не изгражда решението от нулата, а поправя съществуващото

    